package services

/*
 * Author: Oliver McLane
 *
 * Package MalwareAnalysis provides functions for interacting with the Hybrid Analysis API to analyze and retrieve details of malware files.
 * The functions in this package allow users to submit files for analysis, retrieve analysis summaries, and search for file details using hash values.
 */
import (
	"MalwareAnalysisWebApp/pkg/config"
	"MalwareAnalysisWebApp/pkg/models"
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"gorm.io/gorm"
	"io"
	"io/ioutil"
	"mime/multipart"
	"net/http"
	"net/url"
	"os"
)

// AnalyzeFile submits a file for analysis and returns the analysis summary.
func AnalyzeFile(file io.Reader, fileName string, userID uint) (*AnalysisResponse, error) {
	// Base URL for the Hybrid Analysis API
	baseURL := "https://www.hybrid-analysis.com/api/v2"

	// Create a new multipart writer
	var requestBody bytes.Buffer
	writer := multipart.NewWriter(&requestBody)

	// Add the file field to the request body
	fileWriter, err := writer.CreateFormFile("file", fileName)
	if err != nil {
		return nil, err
	}
	_, err = io.Copy(fileWriter, file)
	if err != nil {
		return nil, err
	}

	// Add environment_id field to specify the analysis environment
	if err := writer.WriteField("environment_id", "140"); err != nil {
		return nil, err
	}
	writer.Close()

	// Send POST request to submit the file for analysis
	req, err := http.NewRequest("POST", baseURL+"/submit/file", &requestBody)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Content-Type", writer.FormDataContentType())
	req.Header.Set("api-key", os.Getenv("API_KEY"))
	req.Header.Set("User-Agent", "Falcon")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}

	defer resp.Body.Close()

	// Handle non-200 status codes
	if resp.StatusCode != http.StatusOK && resp.StatusCode != http.StatusCreated {
		responseBody, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("request failed with status: %s", resp.Status)
		}
		return nil, fmt.Errorf("request failed with status: %s, response body: %s", resp.Status, string(responseBody))
	}

	responseBody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// Parse the JSON response to extract the job ID
	var response map[string]interface{}
	if err := json.Unmarshal(responseBody, &response); err != nil {
		return nil, err
	}

	jobID, ok := response["job_id"].(string)
	if !ok {
		return nil, errors.New("job_id not found in response")
	}

	summaryURL := fmt.Sprintf("%s/report/%s/summary", baseURL, jobID)

	// Send GET request to retrieve the analysis summary
	reqSummary, err := http.NewRequest("GET", summaryURL, nil)
	if err != nil {
		return nil, err
	}

	reqSummary.Header.Set("api-key", os.Getenv("API_KEY"))
	reqSummary.Header.Set("User-Agent", "Falcon")

	respSummary, err := client.Do(reqSummary)
	if err != nil {
		return nil, err
	}

	defer respSummary.Body.Close()
	// Read the response body
	bodyBytes, err := ioutil.ReadAll(respSummary.Body)
	if err != nil {
		return nil, err
	}

	if respSummary.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("summary request failed with status: %s", respSummary.Status)
	}

	bodyString := string(bodyBytes)

	var analysisData AnalysisResponse
	if err := json.Unmarshal([]byte(bodyString), &analysisData); err != nil {
		return nil, err
	}
	// Check if the hash already exists in the DB
	var hash models.Hash
	result := config.DB.Where("file_hash = ?", analysisData.Hash).First(&hash)

	var user models.User
	config.DB.First(&user, userID)

	if errors.Is(result.Error, gorm.ErrRecordNotFound) {
		// Hash doesn't exist in DB, create new hash and association with user
		newHash := models.Hash{
			FileHash:     analysisData.Hash,
			Verdict:      analysisData.Verdict,
			ThreatLevel:  analysisData.ThreatLevel,
			Type:         analysisData.Type,
			VX_Family:    analysisData.VX_Family,
			IsSubmission: true,
		}
		user.Hashes = append(user.Hashes, newHash)
		config.DB.Save(&user)
	} else {
		// Hash exists, ensure the user-hash association exists
		var existingHash models.Hash
		config.DB.Model(&user).Association("Hashes").Find(&existingHash, hash)
		if existingHash.ID == 0 {
			config.DB.Model(&user).Association("Hashes").Append(&hash)
		}
	}

	// Return the summary response
	return &analysisData, nil
}

// DetailsHash retrieves details of a file by its hash value.
func DetailsHash(fileHash string, userID uint) (*[]HashResponse, error) {
	// Base URL for the Hybrid Analysis API
	baseURL := "https://www.hybrid-analysis.com/api/v2"

	// Construct query parameters
	queryParams := url.Values{"hash": []string{fileHash}}

	// Encode query parameters as form data
	formData := bytes.NewBufferString(queryParams.Encode())

	// Create a POST request to search by hash
	req, err := http.NewRequest("POST", baseURL+"/search/hash", formData)
	if err != nil {
		return nil, err
	}
	req.Header.Set("api-key", os.Getenv("API_KEY"))
	req.Header.Set("User-Agent", "Falcon")
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	// Send the POST request
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// Handle non-200 status codes
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("search by hash request failed with status: %s", resp.Status)
	}

	// Parse the response body
	var responses []HashResponse
	if err := json.NewDecoder(resp.Body).Decode(&responses); err != nil {
		return nil, err
	}
	if len(responses) > 0 {
		var hash models.Hash
		result := config.DB.Where("file_hash = ?", responses[0].Hash).First(&hash)

		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			// Hash doesn't exist, so create it
			newHash := models.Hash{
				FileHash:     responses[0].Hash,
				Verdict:      responses[0].Verdict,
				ThreatLevel:  responses[0].ThreatLevel,
				Type:         responses[0].Type,
				VX_Family:    responses[0].VX_Family,
				IsSubmission: false,
			}

			// Retrieve or create the user
			var user models.User
			config.DB.First(&user, userID)

			// Create the new hash and its association with the user
			user.Hashes = append(user.Hashes, newHash)
			config.DB.Save(&user)
		} else {
			// Hash exists, just ensure the association with this user exists
			var user models.User
			config.DB.First(&user, userID)

			var existingAssociation models.Hash
			config.DB.Model(&user).Association("Hashes").Find(&existingAssociation, hash)

			if existingAssociation.ID == 0 {
				// No association exists, create it
				config.DB.Model(&user).Association("Hashes").Append(&hash)
			}
		}
	}
	return &responses, nil
}

// HashResponse struct represents the response format for file hash details.
type HashResponse struct {
	Hash            string        `json:"sha256"`
	Verdict         string        `json:"verdict"`
	ThreatLevel     int           `json:"threat_score"`
	MitreAttacks    []MitreAttack `json:"mitre_attcks"`
	Type            string        `json:"type"`
	VX_Family       string        `json:"vx_family"`
	TotalSignatures int           `json:"total_signatures"`
	Hosts           []string      `json:"hosts"`
	Domains         []string      `json:"domains"`
	Tags            []string      `json:"tags"`
	Signatures      []Signature   `json:"signatures"`
}

// AnalysisResponse struct represents the response format for analysis details.
type AnalysisResponse struct {
	Hash         string        `json:"sha256"`
	Verdict      string        `json:"verdict"`
	ThreatLevel  int           `json:"threat_level"`
	MitreAttacks []MitreAttack `json:"mitre_attcks"`
	Type         string        `json:"type"`
	VX_Family    string        `json:"vx_family"`
	DateAnalysis string        `json:"analysis_start_time"`
	Hosts        []string      `json:"hosts"`
	Domains      []string      `json:"domains"`
	Tags         []string      `json:"tags"`
	Signatures   []Signature   `json:"signatures"`
}

// Signature struct represents the signature details.
type Signature struct {
	ThreatLevel      int    `json:"threat_level"`
	ThreatLevelHuman string `json:"threat_level_human"`
	Category         string `json:"category"`
	Identifier       string `json:"identifier"`
	Type             int    `json:"type"`
	Relevance        int    `json:"relevance"`
	Name             string `json:"name"`
	Description      string `json:"description"`
	Origin           string `json:"origin"`
	ATTCKID          string `json:"attck_id"`
	CAPECID          string `json:"capec_id"`
	ATTCKIDWiki      string `json:"attck_id_wiki"`
}

// MitreAttack struct represents MITRE ATT&CK details.
type MitreAttack struct {
	Tactic     string `json:"tactic"`
	Technique  string `json:"technique"`
	AttckID    string `json:"attck_id"`
	AttackWiki string `json:"attck_id_wiki"`
}
