let globalRawData = null;
let signaturesPerPage = 10;
let currentPage = 1;

document.getElementById('searchForm').addEventListener('submit', function (e) {
    handleSubmit(e, '/hashdetails');
});

document.querySelector('.upload-form').addEventListener('submit', function (e) {
    handleSubmit(e, '/analysis', true);
});

function handleSubmit(e, endpoint, isFileUpload = false) {
    e.preventDefault();

    document.getElementById('loadingSpinner').style.display = 'block';

    let formData = new FormData();

    if (isFileUpload) {
        const file = document.getElementById('file').files[0];
        formData.append('file', file);
    } else {
        const hash = e.target.elements.hash.value;
        formData.append('hash', hash);
    }

    fetch(endpoint, {
        method: 'POST',
        body: formData
    })
        .then(response => response.json())
        .then(data => {
            document.getElementById('loadingSpinner').style.display = 'none';
            document.querySelector('.gray-screen').style.display = 'none';
            document.querySelector('.instruction-text').style.display = 'none';
            document.querySelector('.info-tile').style.display = 'block';
            document.querySelector('.signatures-tile').style.display = 'block';

            let details = isFileUpload ? data.summary : data.details[0];

            globalRawData = details;
            displayInfoTile(details);
            displaySignatures(details.signatures);
            generateTreemap(details);
        })
        .catch(error => console.error('Error fetching data:', error));
}


let uidCounter = 0;

function uid(prefix) {
    return `${prefix}-${++uidCounter}`;
}

function changePage(amount) {
    const numberOfPages = Math.ceil(globalRawData.signatures.length / signaturesPerPage);
    currentPage += amount;

    if (currentPage < 1) currentPage = 1;
    else if (currentPage > numberOfPages) currentPage = numberOfPages;

    document.getElementById("currentPage").textContent = currentPage;

    displaySignatures(globalRawData.signatures);
}

function displayInfoTile(data) {
    const infoContainer = document.querySelector('#infoTile')
    infoContainer.innerHTML = `
        <h4>Hash Analysis Result</h4>
        <p><strong>Hash:</strong> ${data.sha256}</p>
        <p><strong>Verdict:</strong> ${data.verdict}</p>
        <p><strong>Threat Level:</strong> ${data.threat_score}</p>
        <p><strong>Type:</strong> ${data.type}</p>
        <p><strong>VX Family:</strong> ${data.vx_family}</p>
        <p><strong>Total Signatures:</strong> ${data.total_signatures}</p>
        <p><strong>Hosts:</strong> ${data.hosts.join(', ')}</p>
        <p><strong>Domains:</strong> ${data.domains.join(', ')}</p>
        <p><strong>Tags:</strong> ${data.tags.join(', ')}</p>
    `;
}

window.addEventListener('resize', function () {
    generateTreemap(globalRawData);
});

function generateTreemap(rawData) {
    document.getElementById('treemap').style.display = 'block';

    const container = document.querySelector('#treemap');

    const data = transformDataForTreemap(rawData.mitre_attcks);

    const width = container.offsetWidth - 20;
    const height = Math.min(400, window.innerHeight * 0.4);

    d3.select(container).select("svg").remove();

    const svg = d3.select(container).append("svg")
        .attr("width", width)
        .attr("height", height)
        .style("font", "10px sans-serif");

    const root = d3.hierarchy(data)
        .sum(d => d.size)
        .sort((a, b) => b.height - a.height || b.value - a.value);

    d3.treemap()
        .size([width, height])
        .padding(1)
        (root);

    const leaf = svg.selectAll("g")
        .data(root.leaves())
        .join("g")
        .attr("transform", d => `translate(${d.x0},${d.y0})`);

    leaf.append("rect")
        .attr("id", d => (d.leafUid = uid("leaf")).id)
        .attr("width", d => d.x1 - d.x0)
        .attr("height", d => d.y1 - d.y0)
        .attr("fill-opacity", 0.6)
        .attr("fill", "#E60000");

    leaf.append("clipPath")
        .attr("id", d => (d.clipUid = uid("clip")).id)
        .append("use")
        .attr("xlink:href", d => d.leafUid.href);

    leaf.append("text")
        .attr("clip-path", d => d.clipUid)
        .selectAll("tspan")
        .data(d => d.data.name.split(/(?=[A-Z][^A-Z])/g))
        .join("tspan")
        .attr("x", 3)
        .attr("y", (d, i) => `${i * 1.1 + 1}em`)
        .attr("fill-opacity", (d, i) => i === 0 ? 1 : 0.4)
        .text(d => d);


    function transformDataForTreemap(mitre_attcks) {
        const hierarchy = {name: "root", children: []};
        const tacticsMap = {};

        mitre_attcks.forEach(attack => {
            if (!tacticsMap[attack.tactic]) {
                tacticsMap[attack.tactic] = {name: attack.tactic, children: []};
                hierarchy.children.push(tacticsMap[attack.tactic]);
            }
            tacticsMap[attack.tactic].children.push({name: attack.technique, size: 1});
        });

        return hierarchy;
    }

}

function displaySignatures(signatures) {
    const tableBody = document.getElementById("signaturesTable").querySelector("tbody");
    tableBody.innerHTML = "";

    if (signatures.length === 0) {
        const noDataRow = document.createElement("tr");
        const td = document.createElement("td");
        td.setAttribute("colspan", "11");
        td.textContent = "No data";
        td.style.textAlign = "center";
        td.style.backgroundColor = "#f0f0f0";
        noDataRow.appendChild(td);
        tableBody.appendChild(noDataRow);
    } else {
        const start = (currentPage - 1) * signaturesPerPage;
        const end = start + signaturesPerPage;
        const paginatedSignatures = signatures.slice(start, end);

        paginatedSignatures.forEach(signature => {
            const tr = document.createElement("tr");
            const properties = ['threat_level_human', 'category', 'identifier', 'type', 'relevance', 'name', 'description', 'origin', 'attck_id', 'capec_id', 'attck_id_wiki'];

            properties.forEach(prop => {
                const td = document.createElement("td");
                if (prop === 'attck_id_wiki' && signature[prop]) {
                    td.innerHTML = `<a href="${signature[prop]}" target="_blank">Wiki</a>`;
                } else {
                    td.textContent = signature[prop] || 'N/A';
                }
                tr.appendChild(td);
            });

            tableBody.appendChild(tr);
        });
    }
}

function toggleSidebar() {
    const sidebar = document.querySelector('.sidebar');
    const dashboardActions = document.querySelector('.dashboard-actions');

    sidebar.classList.toggle('expanded');

    if (sidebar.classList.contains('expanded')) {
        dashboardActions.style.paddingRight = '160px';
    } else {
        dashboardActions.style.paddingRight = '20px';
    }
}

document.addEventListener("DOMContentLoaded", function() {
    const submissionsLink = document.getElementById('submissions');
    if (submissionsLink) {
        submissionsLink.addEventListener('click', function(e) {
            e.preventDefault();
            fetchSubmissions();
        });
    } else {
    }
});

let currentPage2 = 1;
const itemsPerPage = 10;
let submissions = [];

function fetchSubmissions() {
    fetch('/submissions')
        .then(response => response.json())
        .then(data => {
            submissions = data.hashes;
            currentPage2 = 1;
            renderSubmissionsTable();
        })
        .catch(error => console.error('Error fetching submissions:', error));
}

function renderSubmissionsTable() {
    const mainContent = document.getElementById('main');
    mainContent.innerHTML = '';

    const table = document.createElement('table');
    table.className = 'table table-striped';
    const thead = table.createTHead();
    const tbody = table.createTBody();

    const headerRow = thead.insertRow();
    ['FileHash', 'Verdict', 'Threat Level', 'Type', 'VX Family', 'Is Submission','Updated At'].forEach(headerText => {
        let headerCell = document.createElement('th');
        headerCell.textContent = headerText;
        headerRow.appendChild(headerCell);
    });

    const start = (currentPage2 - 1) * itemsPerPage;
    const paginatedItems = submissions.slice(start, start + itemsPerPage);

    paginatedItems.forEach(sub => {
        let row = tbody.insertRow();
        [sub.FileHash, sub.Verdict, sub.ThreatLevel, sub.Type, sub.VX_Family,  sub.IsSubmission ? 'Yes' : 'No', sub.UpdatedAt].forEach(value => {
            let cell = row.insertCell();
            cell.textContent = value || 'N/A';
            if (value === sub.FileHash) {
                cell.style.cursor = 'pointer';
                cell.title = 'Click to copy';
                cell.onclick = () => navigator.clipboard.writeText(value).then(() => alert('Hash copied to clipboard!'));
            }
        });
    });

    mainContent.appendChild(table);
    mainContent.appendChild(createPaginationControls());
}

function createPaginationControls() {
    const paginationDiv = document.createElement('div');
    paginationDiv.className = 'pagination-controls';

    const prevButton = document.createElement('button');
    prevButton.textContent = 'Prev';
    prevButton.onclick = () => changePage2(-1);

    const nextButton = document.createElement('button');
    nextButton.textContent = 'Next';
    nextButton.onclick = () => changePage2(1);

    prevButton.disabled = currentPage2 === 1;
    nextButton.disabled = currentPage2 * itemsPerPage >= submissions.length;

    paginationDiv.appendChild(prevButton);
    paginationDiv.appendChild(nextButton);

    return paginationDiv;
}

function changePage2(direction) {
    const newPage = currentPage2 + direction;
    const totalPages = Math.ceil(submissions.length / itemsPerPage);

    if (newPage > 0 && newPage <= totalPages) {
        currentPage2 = newPage;
        renderSubmissionsTable();
    }
}
